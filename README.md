# FrameForge Cutlist

Макрос для FreeCAD, который автоматически генерирует список раскроя из 3D-модели каркаса, созданной с помощью плагина **FrameForge**.

> Макрос специализирован для работы с конструкциями, построенными в FrameForge, и использует специфичные для этого плагина особенности работы с профилями, поворотами и скосами.

## Что делает макрос

Макрос анализирует видимые элементы в документе FreeCAD и создаёт оптимизированную таблицу раскроя:

### Основная функциональность

1. **Сбор информации о деталях**
   - Сканирует все профилированные объекты (Profile и TrimmedProfile) в документе
   - Извлекает длину, материал и параметры скосов FrameForge
   - Группирует одинаковые детали и подсчитывает количество
   - Пропускает детали с длиной вне диапазона MIN_LENGTH..MAX_LENGTH

2. **Таблица деталей**
   - Отображает все уникальные спецификации:
     - Материал (семейство профиля)
     - Длина детали (мм)
     - Параметры скосов (если есть)
     - Количество деталей
   - Отсортирована по материалу и длине

3. **Оптимизация раскроя**
   - Вычисляет оптимальный раскрой стандартных длин материала
   - Минимизирует отходы с учётом размера пропила (керфа)
   - Показывает для каждого хлыста:
     - Какие детали из него вырезать
     - Размер остатка после раскроя

## Требования

- **FreeCAD** ≥ 0.21.x с поддержкой макросов
- **Плагин FrameForge** для создания каркасных конструкций
- Конструкция должна быть построена в FrameForge
- Profile объекты должны быть названы по схеме `Profile_<КОД>` (например `Profile_50x50`)

### Поддерживаемые объекты FrameForge

**Profile** — стандартные профили с поддержкой скосов:
- Скосы на начале: `BevelStartCut`, `BevelStartCut1`, `BevelStartCut2`, `BevelStartRotate`
- Скосы в конце: `BevelEndCut`, `BevelEndCut1`, `BevelEndCut2`, `BevelEndRotate`

**TrimmedProfile** — сложная обрезка (End Trim, End Miter):
- Свойства: `TrimmedBody`, `TrimmingBoundary`, `TrimmedProfileType`, `CutType`

## Параметры конфигурации

В начале макроса можно настроить:

```python
DEFAULT_MATERIAL = "Профруба"    # Префикс названия материала
STOCK_LENGTH = 3000.0            # Стандартная длина хлыста (мм)
KERF = 2.0                       # Размер пропила при раскрое (мм)
ROUND_TO = 1                     # Округление к кратному значению (мм)
MIN_LENGTH = 10.0                # Минимальная допустимая длина детали (мм)
MAX_LENGTH = 6000.0              # Максимальная допустимая длина детали (мм)
COLOR_HEADER = (0.85, 0.85, 0.85)  # RGB цвет заголовков таблицы
COLOR_ROW_A / ROW_B              # RGB цвета строк (чередование)
DEBUG = True                     # Вывод отладочной информации в консоль
```

## Использование

1. Откройте документ FreeCAD с моделью каркаса, построенной в FrameForge
2. Убедитесь, что Profile объекты видимы (их видимость отмечена в дереве объектов)
3. Запустите этот макрос (Макрос → Выполнить макрос)
4. Макрос создаст или обновит таблицу "CutList" с полным раскроем

## Результат

В документе появится новая таблица **CutList** со следующей структурой:

**Часть 1: Список деталей**
- Каждая строка — уникальная спецификация детали
- Столбцы: Материал, Длина, углы скосов (если есть), Количество

**Часть 2: План раскроя**
- Для каждого типа материала: как оптимально вырезать детали из стандартных хлыстов
- Столбцы: Номер хлыста, Деталь 1..5 (размеры), Остаток
- Остаток — материал, который остаётся после резки

## Как работает макрос

### Сбор информации о профилях

Макрос ищет объекты, названные по схеме `Profile_*`:
```python
code = get_profile_code(obj)  # Извлекает КОД из Profile_КОД
material = f"{DEFAULT_MATERIAL} {code}"  # Составляет название материала
```

### Параметры скосов

Макрос пытается получить свойства скосов из объекта Profile:
- `BevelStartCut`, `BevelEndCut` — величины скосов (в мм)
- `BevelStartRotate`, `BevelEndRotate` — углы поворота второго скоса (в градусах)

Если свойства отсутствуют, используются значения 0.

### Оптимизация раскроя

Алгоритм `pack_stock()` минимизирует отходы:
1. Сортирует детали по убыванию длины (First Fit Decreasing)
2. Для каждой детали пытается поместить её в существующий хлыст
3. При расчёте учитывает кераф между деталями: `used = sum(stock) + KERF * (len(stock))`
4. Если не умещается — создаёт новый хлыст
